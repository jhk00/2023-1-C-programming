#include <stdio.h>
struct test {
	int a, b;
};

int main(void) {
	struct test st;// struct test 역시 int나 char 처럼 하나의 타입
	struct test* ptr;  //  "struct test 형을 가리키는 포인터 ptr" , ptr 은 절대로 구조체가 아니라는 것
	
	ptr = &st;
/*
	"아까 구조체는 단순히 원소의 크기가 제각각인 배열이라면서요? 
	그러면 구조체도 배열처럼 변수의 이름이 그 주소값이 되어야 하는 것 아닌가요? 
	다시 말해 우리가 int arr[100]; 을 정의했다면 이를 가리키는 포인터를 정의할 때 
	int *ptr = arr 이라고 하지 int *ptr = &arr 이라 하지 않잖아요?"

	상당히 좋은 질문 입니다. 하지만 조금 아래에 보면 구조체 변수의 이름은 역할이 살짝 다르다는 것을 알게 됩니다. 
	그냥 보통 변수 처럼, (그래서 구조체 변수라 부르지, 구조체 '배열' 이라고 부르지 않잖아요) & 를 붙여 
	구조체가 정의된 메모리의 주소값을 얻어온다고 생각해주세요.
*/
	(*ptr).a = 1;
	(*ptr).b = 2;
//. 이 * 보다 우선순위가 높다는 것입니다.
// ptr->a = 1;
//	ptr->b = 2;
//	위와 같이(*ptr).a = 1 이라는 문장을 ptr->a = 1 로 간단히 표현할 수 있습니다.
//	아래 ptr->b = 2 역시(*ptr).b = 2 와 정확히 일치하는 문장입니다.단순히 사용자의 편의를 위해서->라는 새로운 기호를 도입한 것 뿐이지요. (이 기호는 위의 우선 순위 표 맨 위에서도 볼 수 있습니다)


	printf("st 의 a 멤버 : %d \n", st.a);
	printf("st 의 b 멤버 : %d \n", st.b);

	return 0;
}