/*
#include <stdio.h>

int main(void) {
	int a[5] = { 1,2,3,4,5 };
	int* ptr = a;
	// a라는 배열을 포인터로 참조( reference)
	printf("%p, %p\n", a,ptr); 
	// a 는 a의 시작주소값 - a[0]의 주소값 가지고 있음
	printf("%p, %p\n", &a[0], ptr);
	// a 는 a의 시작주소값 - a[0]의 주소값 가지고 있음, 하지만 a[0] 은 주소값이 아님. a[0]은 배열의 원소 1 값
	for (int i = 0; i < 5 ; i++) {
		printf("%d, %d\n", a[i], *(ptr + i));
	}
	// a[i] = *(ptr+i) 는 같은 값을 가짐

	/*
	int a[5];
	int b[5] = { 5, 3, 1, 2, 4 };
	a = b;
	a는 b와 크기가 같고 자료형이 같음에도 불구하고 
	이와 같은 코드는 컴파일 에러를 불러일으키게 되는 겁니다.
	a는 a[0]의 주소입니다.b 역시 b[0]의 주소입니다.
	주소는 read - only입니다.즉, 값을 대입할 수가 없습니다 절대로!
	위의 코드는 이것과 같은 얘기가 됩니다.
	&a[0] = &b[0] 이라는 거죠.
	*/

	// 올바른 방법

/*
	int* a;
	int b[5] = { 5, 3, 1, 2, 4 };
	a = b; //a=&b[0]과 같음.




	return 0;
}
*/
